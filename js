一.this的指向问题
  1.this的指向是在函数调用时确定,而不是在函数定义时确定。
  2.this的指向问题大约有以下几种情况
    1.当函数作为对象的方法被调用时,this就会指向该对象
    2.作为普通函数被调用,this指向window(非严格模式)
    3.通过new调用，this指向生成的对象
    4.apply,call。修改this指向后，this指向修改后的对象。
  特别的:对于箭头函数的指向:箭头函数中的this绑定，看的是this所在的函数，定义在哪个对象下
  就绑定哪个对象。
二.说一下什么是闭包，为什么要使用闭包(使用闭包饿的场合)，使用闭包有什么危害？
  闭包就是函数内嵌套函数，且外部函数使用了内部函数的变量或者参数。因此，形成闭包的两个必要条件是：
      1.函数嵌套函数
      2.外部函数使用了内部函数的变量或者参数
  变量的使用场合:
      1.私有化变量:如果我们想要定义变量不能被外界访问，只能够通过内部自己定义的方法进行访问。那么就可以使用闭包。
      对于外部函数定义的变量，函数外是无法访问的，而内部函数是可以访问的，因此这个变量就相当于私有化了。
      2.模块化开发，防止污染全局变量。闭包内部定义的变量，如果跟外面定义的变量同名了，那么也不会对外面的变量
      产生影响。因为根据作用域链的查找顺序，会先从函数内部查找，如果内部有就不会往外查找了。这样就避免了对外部变量的
      影响。
  闭包的缺陷：
    由于使用闭包变量会始终保存在内存中，这样的话会增大内存的使用量，使用不当会造成内存泄漏
    如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其他函数中创建函数是不明智的。
三.说一下作用域和作用域链
  作用域:是指函数和变量的能够被访问的范围。通常来说分为全局作用域和局部作用域。
  全局作用域定义的变量和函数在任何地方都可以被访问。局部作用域定义的变量和函数只能够在局部范围内被访问
  作用域链：是定义一条变量被有序访问的规则。通常来说局部作用域能够访问全局范围内的变量，但是全局无法访问局部的变量
四.说一下原型(对象)和原型链
  函数类型的对象具有内置的属性prototype,这个属性指向一个对象，这个对象就是原型对象。
  原型链:每个对象都有自己的原型对象，原型对象又有自己的原型，这些原型组成原型链，直到某个对象的原型为null为止.
五.说一下继承的几种方式
六.说一下事件流
事件流描述的是从页面中接收事件的顺序(注意：只是接收事件，并没有调用事件处理函数)，可以分为事件补获阶段，处于目标阶段，事件冒泡阶段。
其中需要注意的是addEevntListener方法的最后一个参数如果为true,则表示在捕获阶段调用事件处理函数
如果为false则表示在冒泡阶段调用事件处理函数。
事件捕获阶段：实际目标(div)在捕获阶段不会接收事件，也就是说在捕获阶段，事件在document到html再到body就停止了
处于目标阶段：事件在div上发生并处理，但是事件处理会被看作是冒泡阶段的一部分
冒泡阶段：事件又传播回文档。
七：哪些事件不支持冒泡事件？
鼠标事件：mouseleave mouseenter
焦点事件：blur focus
ui事件：scroll resize
之所以不支持不支持冒泡事件是因为这些事件是某些对象所特有的。比如blur focus通常是input元素的事件
八：事件委托
所谓事件委托是指不将事件函数直接绑定在目标元素身上，而是绑定在目标元素的氟元素身上，利用事件冒泡的机制
通过target来获取到目标元素，从而调用事件处理函数的机制。
优点是：可以比较适合动态元素的绑定，新添加的子元素也能够有事件函数。能够触发事件。
九：调用js的new操作符发生了什么？
创建了一个新的对象，这个对象的原型指向构造函数的prototype，把this指向了这个对象，返回这个新创建的对象。
九：call,apply,bind的区别
相同点：call,apply,bind都能够改变this的指向。
区别：
  call接收的第二个参数是arg1,arg2的形式。
  apply接收的第二个参数是数组的形式
  bind返回的是改变了this指向的一个函数。
十深拷贝和浅拷贝
十一：setTimeout和setInterval的机制？如何通过setTimeout来实现一个setInterval?
由于js是单线程的，浏览器遇到setTimeout和setInterval会先执行完当前的代码块，
在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后
会看下事件队列里有没有任务，没有的话才执行定时器里的代码.
setTimeout实现setInterval
    var count = 0;
    function interval(fn,t) {
        fn()
        if(count<=5){
          setTimeout(arguments.callee(fn,t),t)
        }
    }
    interval(()=>{
      count++;
    console.log(count)},1000)
十二：前端跨域问题：
跨域问题是浏览器处于安全考虑，设计的同源策略，即协议，域名，端口号相同才可以进行通信。
十三：图片预加载和懒加载
预加载：是指提前将所有的图片全都加载完毕，当用户需要查看时，直接从本地缓存中进行渲染。
为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。
否则，如果一个页面的内容过于庞大，会出现留白。







